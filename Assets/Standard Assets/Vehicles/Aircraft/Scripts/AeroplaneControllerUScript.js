public class AeroplaneControllerUScript extends MonoBehaviour
    {
        var  m_MaxEnginePower: float = 40f;        // The maximum output of the engine.
        var  m_Lift: float = 0.002f;               // The amount of lift generated by the aeroplane moving forwards.
        var  m_ZeroLiftSpeed: float = 300;         // The speed at which lift is no longer applied.
        var  m_RollEffect: float = 1f;             // The strength of effect for roll input.
        var  m_PitchEffect: float = 1f;            // The strength of effect for pitch input.
        var  m_YawEffect: float = 0.2f;            // The strength of effect for yaw input.
        var  m_BankedTurnEffect: float = 0.5f;     // The amount of turn from doing a banked turn.
        var  m_AerodynamicEffect: float = 0.02f;   // How much aerodynamics affect the speed of the aeroplane.
        var  m_AutoTurnPitch: float = 0.5f;        // How much the aeroplane automatically pitches when in a banked turn.
        var  m_AutoRollLevel: float = 0.2f;        // How much the aeroplane tries to level when not rolling.
        var  m_AutoPitchLevel: float = 0.2f;       // How much the aeroplane tries to level when not pitching.
        var  m_AirBrakesEffect: float = 3f;        // How much the air brakes effect the drag.
        var  m_ThrottleChangeSpeed: float = 0.3f;  // The speed with which the throttle changes.
        var  m_DragIncreaseFactor: float = 0.001f; // how much drag should increase with speed.

        var  Altitude: float;                     // The aeroplane's height above the ground.
        var  Throttle: float ;                    // The amount of throttle being used.
        var  AirBrakes: boolean;                     // Whether or not the air brakes are being applied.
        var  ForwardSpeed: float;                 // How fast the aeroplane is traveling in it's forward direction.
        var  EnginePower: float;                  // How much power the engine is being given.
        var RollAngle: float;
        var  PitchAngle: float;
        var  RollInput: float=0;
        var  PitchInput: float;
        var  YawInput: float=0;
        var  ThrottleInput: float;

        private var m_OriginalDrag: float;         // The drag when the scene starts.
        private var m_OriginalAngularDrag: float;  // The angular drag when the scene starts.
        private var m_AeroFactor: float;
        private var m_Immobilized = false;   // used for making the plane uncontrollable, i.e. if it has been hit or crashed.
        private var m_BankedTurnAmount: float;
        private var m_Rigidbody: Rigidbody;
	    var  m_WheelColliders:WheelCollider[];
		private var m_xReelPosition : float;			// pozycja na osi OX, której ma trzymać się samolot (chodzi

		var  m_RollSensitivity: float = 1.2f;         // How sensitively the AI applies the roll controls
		var  m_MaxRollAngle: float = 45;             // The maximum angle that the AI will attempt to u
        //var  m_TakeoffHeight: float = 20;            // the AI will fly straight and only pitch upwards until reaching this height
   		var  m_SpeedEffect: float = 0.01f;           // This increases the effect of the controls based on the plane's speed.
   	
        function  Start()
        {
        	mySphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
	mySphere.GetComponent.<Collider>().isTrigger = true;
	var colliderFromT = mySphere.GetComponent("Collider");
	Destroy(colliderFromT);
	mySphere.transform.position = transform.position;
	mySphere.transform.localScale = new Vector3(3,3,3);
	mySphere.GetComponent.<Renderer>().enabled = false;
	
	
            m_Rigidbody = GetComponent.<Rigidbody>();
            // Store original drag settings, these are modified during flight.
            m_OriginalDrag = m_Rigidbody.drag;
            m_OriginalAngularDrag = m_Rigidbody.angularDrag;

			for (var i = 0; i < transform.childCount; i++ )
			{
				for (var componentsInChild in transform.GetChild(i).GetComponentsInChildren.<WheelCollider>())
				{
					componentsInChild.motorTorque = 0.18f;
				}
			}
			m_xReelPosition = transform.position.x;
        }


       	function Move( pitchInput,  throttleInput,  airBrakes)
        {
        	RollInput = 0;        	

            // transfer input parameters into properties.s
            PitchInput = pitchInput;
            ThrottleInput = throttleInput;
            AirBrakes = airBrakes;

			StickToXReel();

            ClampInputs();

            CalculateRollAndPitchAngles();
                       
            AutoLevel();                        

            CalculateForwardSpeed();

            ControlThrottle();

            CalculateDrag();

            CaluclateAerodynamicEffect();

            CalculateLinearForces();

            CalculateTorque();

            CalculateAltitude();
            
            
        }

private var mySphere : GameObject =null;

		//keeps plane from detouring from desired path	
		function StickToXReel()
		{
		 	if (Altitude <= 0.1){
		 		return;
		 	}
		 
			// adjust the yaw towards the target
            //var localTarget = transform.InverseTransformPoint(new Vector3(m_xReelPosition, transform.position.y+transform.up,transform.position.z+transform.forward));            var targetAngleYaw = Mathf.Atan2(localTarget.x, localTarget.z);
            var localTarget = transform.position + (transform.up * 2) + (transform.forward * 2);
			localTarget.x = m_xReelPosition;
			//Debug.Log('local przed: '+localTarget);
		mySphere.transform.position = localTarget;
  		  		    
  		    localTarget = transform.InverseTransformPoint(localTarget);
			//localTarget.x = -localTarget.x;
			//localTarget.x = m_xReelPosition;
			//Debug.Log('local po: '+localTarget);
			//Debug.Log('plane pos: '+transform.position);
			
    
			var targetAngleYaw = Mathf.Atan2(localTarget.x, localTarget.z);
            
            // clamp the planes roll
            var desiredRoll = Mathf.Clamp(targetAngleYaw, -m_MaxRollAngle*Mathf.Deg2Rad, m_MaxRollAngle*Mathf.Deg2Rad);
            //Debug.Log('desiredroll: '+desiredRoll);
            var yawInput:float = 0;
            var rollInput:float = 0;
          
            // now we have taken off to a safe height, we can use the rudder and ailerons to yaw and roll
            yawInput = targetAngleYaw;
            rollInput = -(RollAngle - desiredRoll)*m_RollSensitivity;
         //   }

            // adjust how fast the AI is changing the controls based on the speed. Faster speed = faster on the controls.
            var currentSpeedEffect = 1 + (ForwardSpeed*m_SpeedEffect);
            rollInput *= currentSpeedEffect;
            yawInput *= currentSpeedEffect;
//Debug.Log('roll input maly: '+rollInput);
		    // pass the current input to the plane (false = because AI never uses air brakes!)
            RollInput = rollInput;
            YawInput = yawInput;
		}

        function ClampInputs()
        {
            // clamp the inputs to -1 to 1 range
            RollInput = Mathf.Clamp(RollInput, -1, 1);
            PitchInput = Mathf.Clamp(PitchInput, -1, 1);
            YawInput = Mathf.Clamp(YawInput, -1, 1);
            ThrottleInput = Mathf.Clamp(ThrottleInput, -1, 1);
        }


        function CalculateRollAndPitchAngles()
        {
            // Calculate roll & pitch angles
            // Calculate the flat forward direction (with no y component).
            var flatForward = transform.forward;
            flatForward.y = 0;
            // If the flat forward vector is non-zero (which would only happen if the plane was pointing exactly straight upwards)
            if (flatForward.sqrMagnitude > 0)
            {
                flatForward.Normalize();
                // calculate current pitch angle
                var localFlatForward = transform.InverseTransformDirection(flatForward);
                PitchAngle = Mathf.Atan2(localFlatForward.y, localFlatForward.z);
                // calculate current roll angle
                var flatRight = Vector3.Cross(Vector3.up, flatForward);
                var localFlatRight = transform.InverseTransformDirection(flatRight);
                RollAngle = Mathf.Atan2(localFlatRight.y, localFlatRight.x);
            }
        }


        function AutoLevel()
        {
            // The banked turn amount (between -1 and 1) is the sine of the roll angle.
            // this is an amount applied to elevator input if the user is only using the banking controls,
            // because that's what people expect to happen in games!
            m_BankedTurnAmount = Mathf.Sin(RollAngle);
            // auto level roll, if there's no roll input:
            if (RollInput == 0f)
            {
                RollInput = -RollAngle*m_AutoRollLevel;
            }
            // auto correct pitch, if no pitch input (but also apply the banked turn amount)
            if (PitchInput == 0f)
            {
                PitchInput = -PitchAngle*m_AutoPitchLevel;
                PitchInput -= Mathf.Abs(m_BankedTurnAmount*m_BankedTurnAmount*m_AutoTurnPitch);
            }
        }


        function CalculateForwardSpeed()
        {
            // Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
            var localVelocity = transform.InverseTransformDirection(m_Rigidbody.velocity);
            ForwardSpeed = Mathf.Max(0, localVelocity.z);
        }


        function ControlThrottle()
        {
            // override throttle if immobilized
            if (m_Immobilized)
            {
                ThrottleInput = -0.5f;
            }

            // Adjust throttle based on throttle input (or immobilized state)
            Throttle = Mathf.Clamp01(Throttle + ThrottleInput*Time.deltaTime*m_ThrottleChangeSpeed);

            // current engine power is just:
            EnginePower = Throttle*m_MaxEnginePower;
        }


        function CalculateDrag()
        {
            // increase the drag based on speed, since a constant drag doesn't seem "Real" (tm) enough
            var extraDrag = m_Rigidbody.velocity.magnitude*m_DragIncreaseFactor;
            // Air brakes work by directly modifying drag. This part is actually pretty realistic!
            m_Rigidbody.drag = (AirBrakes ? (m_OriginalDrag + extraDrag)*m_AirBrakesEffect : m_OriginalDrag + extraDrag);
            // Forward speed affects angular drag - at high forward speed, it's much harder for the plane to spin
        
            m_Rigidbody.angularDrag = m_OriginalAngularDrag*ForwardSpeed;
        }


        function CaluclateAerodynamicEffect()
        {
            // "Aerodynamic" calculations. This is a very simple approximation of the effect that a plane
            // will naturally try to align itself in the direction that it's facing when moving at speed.
            // Without this, the plane would behave a bit like the asteroids spaceship!
            if (m_Rigidbody.velocity.magnitude > 0)
            {
                // compare the direction we're pointing with the direction we're moving:
                m_AeroFactor = Vector3.Dot(transform.forward, m_Rigidbody.velocity.normalized);
                // multipled by itself results in a desirable rolloff curve of the effect
                m_AeroFactor *= m_AeroFactor;
                // Finally we calculate a new velocity by bending the current velocity direction towards
                // the the direction the plane is facing, by an amount based on this aeroFactor
                var newVelocity = Vector3.Lerp(m_Rigidbody.velocity, transform.forward*ForwardSpeed,
                                               m_AeroFactor*ForwardSpeed*m_AerodynamicEffect*Time.deltaTime);
                newVelocity.x = 0;
                m_Rigidbody.velocity = newVelocity;

                // also rotate the plane towards the direction of movement - this should be a very small effect, but means the plane ends up
                // pointing downwards in a stall
                m_Rigidbody.rotation = Quaternion.Slerp(m_Rigidbody.rotation,
                                                      Quaternion.LookRotation(m_Rigidbody.velocity, transform.up),
                                                      m_AerodynamicEffect*Time.deltaTime);
            }
        }


        function CalculateLinearForces()
        {
            // Now calculate forces acting on the aeroplane:
            // we accumulate forces into this variable:
            var forces = Vector3.zero;
            // Add the engine power in the forward direction
            forces += EnginePower*transform.forward;
            // The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)
            var liftDirection = Vector3.Cross(m_Rigidbody.velocity, transform.right).normalized;
      //      var liftDirection = Vector3.Cross(m_Rigidbody.velocity, transform.up).normalized;
            // The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps
            // shortly after takeoff, giving the plane less drag, but less lift. Because we don't simulate flaps, this is
            // a simple way of doing it automatically:
            var zeroLiftFactor = Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed);
            // Calculate and add the lift power
            var liftPower = ForwardSpeed*ForwardSpeed*m_Lift*zeroLiftFactor*m_AeroFactor;
            forces += liftPower*liftDirection;
            // Apply the calculated forces to the the Rigidbody
            
       //     Debug.Log('forces: '+forces);
            m_Rigidbody.AddForce(forces);
        }


       function CalculateTorque()
        {
            // We accumulate torque forces into this variable:
            var torque = Vector3.zero;
            // Add torque for the pitch based on the pitch input.
            torque += PitchInput*m_PitchEffect*transform.right;
            // Add torque for the yaw based on the yaw input.
            torque += YawInput*m_YawEffect*transform.up;
            // Add torque for the roll based on the roll input.
            torque += -RollInput*m_RollEffect*transform.forward;
            // Add torque for banked turning.
     //       torque += m_BankedTurnAmount*m_BankedTurnEffect*transform.up;
            // The total torque is multiplied by the forward speed, so the controls have more effect at high speed,
            // and little effect at low speed, or when not moving in the direction of the nose of the plane
            // (i.e. falling while stalled)
            
        //    torque.x=0;
            
            m_Rigidbody.AddTorque(torque*ForwardSpeed*m_AeroFactor);
        }


        function CalculateAltitude()
        {
            // Altitude calculations - we raycast downwards from the aeroplane
            // starting a safe distance below the plane to avoid colliding with any of the plane's own colliders
            var ray = new Ray(transform.position - Vector3.up*10, -Vector3.up);
            var hit:RaycastHit;
            Altitude = Physics.Raycast(ray, hit) ? hit.distance + 10 : transform.position.y;
        }


        // Immobilize can be called from other objects, for example if this plane is hit by a weapon and should become uncontrollable
       function Immobilize()
        {
            m_Immobilized = true;
        }


        // Reset is called via the ObjectResetter script, if present.
        function Reset()
        {
            m_Immobilized = false;
        }
    }

